#!/usr/bin/env python3

# SPDX-FileCopyrightText: 2023 Technology Innovation Institute (TII)
#
# SPDX-License-Identifier: Apache-2.0

""" Python script to run and summarize vulnerability scans for Ghaf """

import os
import sys
import argparse
import logging
import subprocess
import tempfile
import shutil
from pathlib import Path
import git

from colorlog import ColoredFormatter, default_log_colors

###############################################################################

DATADIR_FROM_REPOROOT = "ci/vulnerability-scan/data"
LOG_SPAM = logging.DEBUG - 1
LOG = logging.getLogger(os.path.abspath(__file__))

###############################################################################


def getargs():
    """Parse command line arguments"""
    desc = "Helper script to run and summarize vulnerability scans."
    epil = "Example: ghafscan /path/to/ghaf/repo"
    parser = argparse.ArgumentParser(description=desc, epilog=epil)
    helps = (
        "Path to target Ghaf git repository. Script will search for a valid "
        "git repository from the given path or any of its parent directories."
    )
    parser.add_argument("TARGET", help=helps, type=Path)
    helps = "Set the debug verbosity level between 0-3 (default: --verbose=1)"
    parser.add_argument("--verbose", help=helps, type=int, default=1)
    return parser.parse_args()


################################################################################


# Utils


def set_log_verbosity(verbosity=1):
    """Set logging verbosity"""
    log_levels = [logging.NOTSET, logging.INFO, logging.DEBUG, LOG_SPAM]
    verbosity = min(len(log_levels) - 1, max(verbosity, 0))
    _init_logging(verbosity)


def _init_logging(verbosity=1):
    """Initialize logging"""
    if verbosity == 0:
        level = logging.NOTSET
    elif verbosity == 1:
        level = logging.INFO
    elif verbosity == 2:
        level = logging.DEBUG
    else:
        level = LOG_SPAM
    if level <= logging.DEBUG:
        logformat = (
            "%(log_color)s%(levelname)-8s%(reset)s "
            "%(filename)s:%(funcName)s():%(lineno)d "
            "%(message)s"
        )
    else:
        logformat = "%(log_color)s%(levelname)-8s%(reset)s %(message)s"
    logging.addLevelName(LOG_SPAM, "SPAM")
    default_log_colors["INFO"] = "fg_bold_white"
    default_log_colors["DEBUG"] = "fg_bold_white"
    default_log_colors["SPAM"] = "fg_bold_white"
    formatter = ColoredFormatter(logformat, log_colors=default_log_colors)
    if LOG.hasHandlers() and len(LOG.handlers) > 0:
        stream = LOG.handlers[0]
    else:
        stream = logging.StreamHandler()
    stream.setFormatter(formatter)
    if not LOG.hasHandlers():
        LOG.addHandler(stream)
    LOG.setLevel(level)


def exit_unless_command_exists(name):
    """Check if `name` is an executable in PATH"""
    name_is_in_path = shutil.which(name) is not None
    if not name_is_in_path:
        LOG.fatal("command '%s' is not in PATH", name)
        sys.exit(1)


def exec_cmd(cmd, raise_on_error=True, return_error=False, loglevel=logging.DEBUG):
    """Run shell command cmd"""
    command_str = " ".join(cmd)
    LOG.log(loglevel, "Running: %s", command_str)
    try:
        ret = subprocess.run(cmd, capture_output=True, encoding="utf-8", check=True)
        return ret
    except subprocess.CalledProcessError as error:
        LOG.debug(
            "Error running shell command:\n cmd:   '%s'\n stdout: %s\n stderr: %s",
            command_str,
            error.stdout,
            error.stderr,
        )
        if raise_on_error:
            raise error
        if return_error:
            return error
        return None


###############################################################################


class GhafScanner:
    """Scan vulnerabilities in Ghaf repo"""

    def __init__(self, ghaf_path):
        self.lockfile = None
        self.lockfile_bak = None
        self.tmpdir = None
        ghaf_path_abs = Path(ghaf_path).resolve().as_posix()
        LOG.debug("Finding repo based on file path: %s", ghaf_path_abs)
        self.repo = git.Repo(ghaf_path_abs, search_parent_directories=True)
        LOG.info("Repo HEAD at: %s", self.repo.rev_parse("HEAD"))
        self.reporoot = Path(self.repo.working_tree_dir)
        self.tmpdir = Path(tempfile.mkdtemp())
        LOG.debug("Using tmpdir: %s", self.tmpdir)
        # Backup the original lockfile
        self.lockfile = self.reporoot / "flake.lock"
        if not self.lockfile.exists():
            LOG.fatal("Missing lockfile: %s", self.lockfile.resolve())
            sys.exit(1)
        self.lockfile_bak = self.tmpdir / "flake.lock"
        shutil.copy(self.lockfile, self.lockfile_bak)
        # Init datadir and files
        self.datadir = self.reporoot / DATADIR_FROM_REPOROOT
        self.datadir.mkdir(parents=True, exist_ok=True)
        LOG.debug("Using datadir: %s", self.datadir)

    def __del__(self):
        if self.lockfile and self.lockfile_bak:
            LOG.debug("Restoring original lockfile")
            shutil.copy(self.lockfile_bak, self.lockfile)
        if self.tmpdir:
            LOG.debug("Removing tmpdir: %s", self.tmpdir)
            shutil.rmtree(self.tmpdir)

    def scan_target(self, target):
        """Scan given flake target"""
        LOG.info("Scanning flake target '%s'", target)
        # Store new scan results to this file
        out_new = self.datadir / f"vulns_new__{target}.csv"
        # Backup earlier scan results for reference
        out_old = self.datadir / f"vulns_old__{target}.csv"
        if out_new.exists():
            shutil.copy(out_new, out_old)
        # First scan: before lockfile update
        LOG.info("Scanning current vulnerabilities")
        drv_path = self._evaluate_target_drv(target)
        cmd = ["nix_secupdates.py", str(drv_path), "--buildtime", "--out", str(out_new)]
        cmd.append("--verbose=2")
        exec_cmd(cmd)
        # Update lockfile
        self._update_lockfile()
        # Second scan: after lockfile update
        LOG.info("Scanning vulnerabilities after lockfile update")
        drv_path = self._evaluate_target_drv(target)
        out_upd = self.datadir / f"vulns_new_lock_updated__{target}.csv"
        cmd = ["nix_secupdates.py", str(drv_path), "--buildtime", "--out", str(out_upd)]
        cmd.append("--verbose=2")
        exec_cmd(cmd)

    def _evaluate_target_drv(self, target):
        cmd = ["nix", "eval", f"{str(self.reporoot)}#{target}.drvPath"]
        ret = exec_cmd(cmd)
        drv_path = Path(str(ret.stdout).strip('"\n\t '))
        LOG.info("Target '%s' evaluates to derivation: %s", target, drv_path)
        return drv_path

    def _update_lockfile(self):
        LOG.info("Updating lockfile at: %s", self.lockfile)
        LOG.debug("Lockfile contents:\n%s", self.lockfile.read_text())
        cmd = ["nix", "flake", "lock", str(self.reporoot), "--update-input", "nixpkgs"]
        exec_cmd(cmd)
        LOG.debug("Lockfile contents after update:\n%s", self.lockfile.read_text())


################################################################################


def main():
    """main entry point"""
    args = getargs()
    set_log_verbosity(args.verbose)
    # Fail early if following commands are not in PATH
    exit_unless_command_exists("git")
    exit_unless_command_exists("nix_secupdates.py")
    # Scan the following targets
    scanner = GhafScanner(args.TARGET)
    scanner.scan_target("generic-x86_64-release")


if __name__ == "__main__":
    main()

################################################################################
